# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import pydantic

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...errors.bad_request_error import BadRequestError
from ...errors.unauthorized_error import UnauthorizedError
from ...types.connect_webviews_create_request_accepted_providers_item import (
    ConnectWebviewsCreateRequestAcceptedProvidersItem,
)
from ...types.connect_webviews_create_request_custom_metadata_value import (
    ConnectWebviewsCreateRequestCustomMetadataValue,
)
from ...types.connect_webviews_create_request_device_selection_mode import (
    ConnectWebviewsCreateRequestDeviceSelectionMode,
)
from ...types.connect_webview import ConnectWebview
from ...types.connect_webviews_create_request_provider_category import ConnectWebviewsCreateRequestProviderCategory
from ...types.connect_webviews_create_response import ConnectWebviewsCreateResponse
from ...types.connect_webviews_delete_response import ConnectWebviewsDeleteResponse
from ...types.connect_webviews_get_response import ConnectWebviewsGetResponse
from ...types.connect_webviews_list_response import ConnectWebviewsListResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ConnectWebviewsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def create(
        self,
        *,
        device_selection_mode: typing.Optional[ConnectWebviewsCreateRequestDeviceSelectionMode] = OMIT,
        custom_redirect_url: typing.Optional[str] = OMIT,
        custom_redirect_failure_url: typing.Optional[str] = OMIT,
        accepted_providers: typing.Optional[typing.List[ConnectWebviewsCreateRequestAcceptedProvidersItem]] = OMIT,
        provider_category: typing.Optional[ConnectWebviewsCreateRequestProviderCategory] = OMIT,
        custom_metadata: typing.Optional[
            typing.Dict[str, typing.Optional[ConnectWebviewsCreateRequestCustomMetadataValue]]
        ] = OMIT,
    ) -> ConnectWebview:
        """
        Parameters:
            - device_selection_mode: typing.Optional[ConnectWebviewsCreateRequestDeviceSelectionMode].

            - custom_redirect_url: typing.Optional[str].

            - custom_redirect_failure_url: typing.Optional[str].

            - accepted_providers: typing.Optional[typing.List[ConnectWebviewsCreateRequestAcceptedProvidersItem]].

            - provider_category: typing.Optional[ConnectWebviewsCreateRequestProviderCategory].

            - custom_metadata: typing.Optional[typing.Dict[str, typing.Optional[ConnectWebviewsCreateRequestCustomMetadataValue]]].
        """
        _request: typing.Dict[str, typing.Any] = {}
        if device_selection_mode is not OMIT:
            _request["device_selection_mode"] = device_selection_mode
        if custom_redirect_url is not OMIT:
            _request["custom_redirect_url"] = custom_redirect_url
        if custom_redirect_failure_url is not OMIT:
            _request["custom_redirect_failure_url"] = custom_redirect_failure_url
        if accepted_providers is not OMIT:
            _request["accepted_providers"] = accepted_providers
        if provider_category is not OMIT:
            _request["provider_category"] = provider_category
        if custom_metadata is not OMIT:
            _request["custom_metadata"] = custom_metadata
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "connect_webviews/create"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            _parsed_response = pydantic.parse_obj_as(ConnectWebviewsCreateResponse, _response.json())  # type: ignore
            return _parsed_response.connect_webview
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete(self, *, connect_webview_id: str) -> ConnectWebviewsDeleteResponse:
        """
        Parameters:
            - connect_webview_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "connect_webviews/delete"),
            json=jsonable_encoder({"connect_webview_id": connect_webview_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ConnectWebviewsDeleteResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(self, *, connect_webview_id: str) -> ConnectWebview:
        """
        Parameters:
            - connect_webview_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "connect_webviews/get"),
            json=jsonable_encoder({"connect_webview_id": connect_webview_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            _parsed_response = pydantic.parse_obj_as(ConnectWebviewsGetResponse, _response.json())  # type: ignore
            return _parsed_response.connect_webview
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list(self) -> typing.List[ConnectWebview]:
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "connect_webviews/list"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            _parsed_response = pydantic.parse_obj_as(ConnectWebviewsListResponse, _response.json())  # type: ignore
            return _parsed_response.connect_webviews
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def view(self, *, connect_webview_id: str, auth_token: str) -> None:
        """
        Parameters:
            - connect_webview_id: str.

            - auth_token: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "connect_webviews/view"),
            params=remove_none_from_dict({"connect_webview_id": connect_webview_id, "auth_token": auth_token}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncConnectWebviewsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def create(
        self,
        *,
        device_selection_mode: typing.Optional[ConnectWebviewsCreateRequestDeviceSelectionMode] = OMIT,
        custom_redirect_url: typing.Optional[str] = OMIT,
        custom_redirect_failure_url: typing.Optional[str] = OMIT,
        accepted_providers: typing.Optional[typing.List[ConnectWebviewsCreateRequestAcceptedProvidersItem]] = OMIT,
        provider_category: typing.Optional[ConnectWebviewsCreateRequestProviderCategory] = OMIT,
        custom_metadata: typing.Optional[
            typing.Dict[str, typing.Optional[ConnectWebviewsCreateRequestCustomMetadataValue]]
        ] = OMIT,
    ) -> ConnectWebviewsCreateResponse:
        """
        Parameters:
            - device_selection_mode: typing.Optional[ConnectWebviewsCreateRequestDeviceSelectionMode].

            - custom_redirect_url: typing.Optional[str].

            - custom_redirect_failure_url: typing.Optional[str].

            - accepted_providers: typing.Optional[typing.List[ConnectWebviewsCreateRequestAcceptedProvidersItem]].

            - provider_category: typing.Optional[ConnectWebviewsCreateRequestProviderCategory].

            - custom_metadata: typing.Optional[typing.Dict[str, typing.Optional[ConnectWebviewsCreateRequestCustomMetadataValue]]].
        """
        _request: typing.Dict[str, typing.Any] = {}
        if device_selection_mode is not OMIT:
            _request["device_selection_mode"] = device_selection_mode
        if custom_redirect_url is not OMIT:
            _request["custom_redirect_url"] = custom_redirect_url
        if custom_redirect_failure_url is not OMIT:
            _request["custom_redirect_failure_url"] = custom_redirect_failure_url
        if accepted_providers is not OMIT:
            _request["accepted_providers"] = accepted_providers
        if provider_category is not OMIT:
            _request["provider_category"] = provider_category
        if custom_metadata is not OMIT:
            _request["custom_metadata"] = custom_metadata
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "connect_webviews/create"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ConnectWebviewsCreateResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete(self, *, connect_webview_id: str) -> ConnectWebviewsDeleteResponse:
        """
        Parameters:
            - connect_webview_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "connect_webviews/delete"),
            json=jsonable_encoder({"connect_webview_id": connect_webview_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ConnectWebviewsDeleteResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(self, *, connect_webview_id: str) -> ConnectWebviewsGetResponse:
        """
        Parameters:
            - connect_webview_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "connect_webviews/get"),
            json=jsonable_encoder({"connect_webview_id": connect_webview_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ConnectWebviewsGetResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list(self) -> ConnectWebviewsListResponse:
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "connect_webviews/list"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ConnectWebviewsListResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def view(self, *, connect_webview_id: str, auth_token: str) -> None:
        """
        Parameters:
            - connect_webview_id: str.

            - auth_token: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "connect_webviews/view"),
            params=remove_none_from_dict({"connect_webview_id": connect_webview_id, "auth_token": auth_token}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
