# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import pydantic

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...errors.bad_request_error import BadRequestError
from ...errors.unauthorized_error import UnauthorizedError
from ...types.event import Event
from ...types.events_get_response import EventsGetResponse
from ...types.events_list_request_between_item import EventsListRequestBetweenItem
from ...types.events_list_request_event_type import EventsListRequestEventType
from ...types.events_list_request_event_types_item import EventsListRequestEventTypesItem
from ...types.events_list_response import EventsListResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class EventsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get(
        self,
        *,
        event_id: typing.Optional[str] = OMIT,
        event_type: typing.Optional[str] = OMIT,
        device_id: typing.Optional[str] = OMIT,
    ) -> Event:
        """
        Parameters:
            - event_id: typing.Optional[str].

            - event_type: typing.Optional[str].

            - device_id: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {}
        if event_id is not OMIT:
            _request["event_id"] = event_id
        if event_type is not OMIT:
            _request["event_type"] = event_type
        if device_id is not OMIT:
            _request["device_id"] = device_id
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "events/get"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            _parsed_response = pydantic.parse_obj_as(EventsGetResponse, _response.json())  # type: ignore
            return _parsed_response.event # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list(
        self,
        *,
        since: typing.Optional[str] = OMIT,
        between: typing.Optional[typing.List[EventsListRequestBetweenItem]] = OMIT,
        device_id: typing.Optional[str] = OMIT,
        device_ids: typing.Optional[typing.List[str]] = OMIT,
        access_code_id: typing.Optional[str] = OMIT,
        access_code_ids: typing.Optional[typing.List[str]] = OMIT,
        event_type: typing.Optional[EventsListRequestEventType] = OMIT,
        event_types: typing.Optional[typing.List[EventsListRequestEventTypesItem]] = OMIT,
        connected_account_id: typing.Optional[str] = OMIT,
    ) -> typing.List[Event]:
        """
        Parameters:
            - since: typing.Optional[str].

            - between: typing.Optional[typing.List[EventsListRequestBetweenItem]].

            - device_id: typing.Optional[str].

            - device_ids: typing.Optional[typing.List[str]].

            - access_code_id: typing.Optional[str].

            - access_code_ids: typing.Optional[typing.List[str]].

            - event_type: typing.Optional[EventsListRequestEventType].

            - event_types: typing.Optional[typing.List[EventsListRequestEventTypesItem]].

            - connected_account_id: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {}
        if since is not OMIT:
            _request["since"] = since
        if between is not OMIT:
            _request["between"] = between
        if device_id is not OMIT:
            _request["device_id"] = device_id
        if device_ids is not OMIT:
            _request["device_ids"] = device_ids
        if access_code_id is not OMIT:
            _request["access_code_id"] = access_code_id
        if access_code_ids is not OMIT:
            _request["access_code_ids"] = access_code_ids
        if event_type is not OMIT:
            _request["event_type"] = event_type
        if event_types is not OMIT:
            _request["event_types"] = event_types
        if connected_account_id is not OMIT:
            _request["connected_account_id"] = connected_account_id
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "events/list"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            _parsed_response = pydantic.parse_obj_as(EventsListResponse, _response.json())  # type: ignore
            return _parsed_response.events if _parsed_response.events is not None else []
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncEventsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get(
        self,
        *,
        event_id: typing.Optional[str] = OMIT,
        event_type: typing.Optional[str] = OMIT,
        device_id: typing.Optional[str] = OMIT,
    ) -> EventsGetResponse:
        """
        Parameters:
            - event_id: typing.Optional[str].

            - event_type: typing.Optional[str].

            - device_id: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {}
        if event_id is not OMIT:
            _request["event_id"] = event_id
        if event_type is not OMIT:
            _request["event_type"] = event_type
        if device_id is not OMIT:
            _request["device_id"] = device_id
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "events/get"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(EventsGetResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list(
        self,
        *,
        since: typing.Optional[str] = OMIT,
        between: typing.Optional[typing.List[EventsListRequestBetweenItem]] = OMIT,
        device_id: typing.Optional[str] = OMIT,
        device_ids: typing.Optional[typing.List[str]] = OMIT,
        access_code_id: typing.Optional[str] = OMIT,
        access_code_ids: typing.Optional[typing.List[str]] = OMIT,
        event_type: typing.Optional[EventsListRequestEventType] = OMIT,
        event_types: typing.Optional[typing.List[EventsListRequestEventTypesItem]] = OMIT,
        connected_account_id: typing.Optional[str] = OMIT,
    ) -> EventsListResponse:
        """
        Parameters:
            - since: typing.Optional[str].

            - between: typing.Optional[typing.List[EventsListRequestBetweenItem]].

            - device_id: typing.Optional[str].

            - device_ids: typing.Optional[typing.List[str]].

            - access_code_id: typing.Optional[str].

            - access_code_ids: typing.Optional[typing.List[str]].

            - event_type: typing.Optional[EventsListRequestEventType].

            - event_types: typing.Optional[typing.List[EventsListRequestEventTypesItem]].

            - connected_account_id: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {}
        if since is not OMIT:
            _request["since"] = since
        if between is not OMIT:
            _request["between"] = between
        if device_id is not OMIT:
            _request["device_id"] = device_id
        if device_ids is not OMIT:
            _request["device_ids"] = device_ids
        if access_code_id is not OMIT:
            _request["access_code_id"] = access_code_id
        if access_code_ids is not OMIT:
            _request["access_code_ids"] = access_code_ids
        if event_type is not OMIT:
            _request["event_type"] = event_type
        if event_types is not OMIT:
            _request["event_types"] = event_types
        if connected_account_id is not OMIT:
            _request["connected_account_id"] = connected_account_id
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "events/list"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(EventsListResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
